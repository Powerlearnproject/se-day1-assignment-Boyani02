[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18366478&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
-Software engineering is the systematic application of engineering principles to design, develop, test, and maintain software.

-Importance:
1. Development of high-quality software with as much as eliminating errors.
2. To guarantee security and compliance with industry standards.
3. Facilitate scaling and maintenance of the software systems.

Identify and describe at least three key milestones in the evolution of software engineering.

1. 1968: The NATO Software Engineering Conference where the term "software engineering" was recognized as a discipline.
2. 1970s: New methodologies are developed and the beginning of Object-Oriented Programming introduced more modularity and reuse in the design and development of software.
3. 1990s - present: The rise of Agile Development that allowed greater flexibility.

List and briefly explain the phases of the Software Development Life Cycle.

1. Requirement Analysis – Understanding what does the user need.
2. Planning – Scope, Budget, and Timelines.
3. Design – Software architecture and design models.
4. Implementation (Coding) – Code writing and integration.
5. Testing – Making sure the software works, hunting down and fixing bugs.
6. Deployment – Releasing the software to end-users.
7. Maintenance – Making updates and fixing bugs after release.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

1. Waterfall methodology is linear and sequential while Agile methodology is iterative and flexible.
2. In waterfall methodology changes	are difficult to incorporate while Agile methodology is easily adaptable to changes.
3. Waterfall methodology provides late feedback while Agile methodology provides continuous feedback.
4. Waterfall methodology is best for large-scale, well-defined projects	while Agile methodology is best for dynamic, fast-changing projects.

-Use case examples:
1. Waterfall: Government or banking systems - used, where the requirements are known and there is predictability.
2. Agile: Mobile app development - is exceedingly dynamic and fast-changing.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software Developer – Writes the code and keeps it maintained, implements emerging features, and fixes bugs.
   
2. Quality Assurance (QA) Engineer – Performs tests, assures software quality, and reports defects.

3. Project Manager – Oversees and manages project scope, timelines, and resources to oversee smooth running. 

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

1. Integrated Development Environments (IDEs)-provide coding tools, debugging, and testing (e.g. VS Code, IntelliJ IDEA).
  
2. Version Control Systems (VCS)-track changes, manage their collaboration and provide backups (e.g., Git, SVN).


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

1. Managing Complexity-Use modularization and design patterns.

2. Keeping Up with New Technologies by doing continuous learning and certifications.

3. Debugging and Testing-Use automated testing frameworks.

4. Communication Issues-Create relevant documentation and have agile meetings.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. Unit Testing-inspects individual components (e.g., functions, classes).

2. Integration Testing- ensures different modules properly work together.

3. System Testing-examines the functionality of the entire system.

4. Acceptance Testing- ensures the software meets the above expectations of users.
   
#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

- Prompt engineering involves crafting precise and effective inputs to optimize responses from AI models thereby providing optimal output in terms of relevance for the data.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

- Vague prompt: Describe cloud computing.
  
- Improved prompt: Explain cloud computing, with its different service models, and provide real-world use cases.

Effectiveness of improved prompt: 
1. Clearer scope which specifies cloud computing service models and real-world applications.
2. More specific: Directs AI to cover key aspects of cloud computing.

